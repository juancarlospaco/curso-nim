<div>
  <section>
    <h1>For</h1>
    <p>El bucle &#x27;for&#x27; sirve para iterar un valor iterable,
    para aplicar algun tipo de logica a los items individualmente,
    es posible iterar por indices o por los items directamente,
    &#x27;for&#x27; itera de inicio a fin de algun argumento iterable.
    El bucle &#x27;for&#x27; puede ser interrumpido usando &#x27;break&#x27;.</p>
    <p>Aqui se presenta el operador &#x27;..&#x27;,
    que sirve para para crear rangos de valores ordinales, como valores numericos.</p>
    <p>Tambien existe el operador &#x27;..&lt;&#x27;, que es similar al &#x27;..&#x27; pero es no-inclusivo,
    quiere decir que el ultimo numero mas alto no esta incluido en el rango generado,
    es decir que &#x27;a..&lt;b&#x27; es igual a &#x27;a..(b - 1)&#x27; pero nos ahorra codigo,
    algunas implementaciones de codigo necesitaran el &#x27;..&#x27; y otras el &#x27;..&lt;&#x27;.</p>
    <code>var secuencia = @[1, 2, 3, 4, 5, 6]
for item in secuencia:
  if item mod 2 == 0:
    echo &quot;item es par&quot;
  else:
    echo &quot;item es impar&quot;

var palabra: string
for item in [&quot;v&quot;, &quot;e&quot;, &quot;r&quot;, &quot;d&quot;, &quot;e&quot;]:
  palabra.add(item)
assert palabra == &quot;verde&quot;

for i in 0..0:
  echo &quot;Esto se ejecuta 1 sola vez por que el rango tiene 1 item&quot;

for i in 5..9:
  echo i
  if i == 7: break</code>
  </section>
  <section>
    <h1>While</h1>
    <p>El bucle &#x27;while&#x27; sirve para repetir un bloque de codigo siempre y
    cuando un argumento de condicion booleana sea verdadera.
    El bucle &#x27;while&#x27; puede ser interrumpido usando &#x27;break&#x27;.</p>
    <p>Aqui se usa por primera vez los operadores &#x27;inc&#x27; y &#x27;dec&#x27;,
    &#x27;inc&#x27; es para incrementar valores ordinales, como valores numericos,
    permite poder escribir &#x27;inc i&#x27; en lugar de &#x27;i = i + 1&#x27;,
    &#x27;dec&#x27; es para decrementar valores, como valores numericos,
    permite poder escribir &#x27;dec i&#x27; en lugar de &#x27;i = i - 1&#x27; y nos ahorra codigo.</p>
    <code>var x = 0
while not(x == 9):
  echo x
  inc x  # x = x + 1

var y = 9
while not(y == 0):
  echo y
  dec y  # y = y - 1

var z = 0
while true:
  echo z
  inc z
  if z == 9: break</code>
  </section>
  <section>
    <h1>Char</h1>
    <p>Ahora que sabemos usar bucles podemos iterar el texto en los &#x27;string&#x27;,
    descubriremos que las letras individuales tambien tienen un tipo concreto,
    el caracter &#x27;char&#x27; representa 1 letra, de ahi viene el nombre &quot;cadena de caracteres&quot;,
    el char se construye con dos comillas simples y solo puede contener 1 caracter.
    El espacio en blanco, tabulador y la nueva linea (salto de linea) tambien son caracteres.</p>
    <p>La computadora representa las letras en el texto como numeros enteros,
    por lo tanto un &#x27;char&#x27; es compatible con un &#x27;int&#x27;, es un valor ordinal numerico,
    &#x27;char&#x27; puede usar &#x27;inc&#x27;, &#x27;dec&#x27;, &#x27;..&#x27;, &#x27;..&lt;&#x27;, &#x27;+&#x27;, &#x27;-&#x27; que vimos anteriormente,
    es posible agregar uno o mas &#x27;char&#x27; a un &#x27;string&#x27; usando &#x27;add&#x27;,
    es posible obtener un &#x27;char&#x27; de un &#x27;string&#x27; por su indice usando &#x27;[]&#x27;,
    es decir &#x27;texto[3]&#x27; para el &#x27;char&#x27; en la posicion &#x27;3&#x27; del &#x27;string&#x27;,
    por ejemplo el valor entero del &#x27;char&#x27; de &#x27;a&#x27; es &#x27;97&#x27;,
    si al &#x27;a&#x27; le sumas 1 obtienes &#x27;b&#x27;, si al &#x27;a&#x27; le sumas 2 obtienes &#x27;c&#x27;, etc.</p>
    <ul>
      <li>&#x27;char&#x27; se puede convertir en &#x27;int&#x27; usando &#x27;ord&#x27;.</li>
      <li>&#x27;int&#x27; se puede convertir en &#x27;char&#x27; usando &#x27;char&#x27;.</li>
    </ul>
    <code>var caracter = &#x27;a&#x27;
assert caracter is char

var texto = &quot;ave&quot;
assert texto[1] == &#x27;v&#x27;
texto.add(&#x27;s&#x27;)
assert texto == &quot;aves&quot;

for letra in &quot;ejemplo&quot;:  # Es posible iterar los &#x27;char&#x27; de un &#x27;string&#x27; directamente.
  echo letra, &#x27; &#x27;, ord(letra)   # &#x27; &#x27; es un char de Espacio.
  assert letra is char
  assert ord(letra) is int

for letra in &#x27;a&#x27;..&#x27;z&#x27;:  # Como es un valor ordinal se puede crear rangos de letras.
  echo letra, &#x27;\t&#x27;, ord(letra)  # &#x27;\t&#x27; es un caracter de Tabulador (Tab).
  assert letra is char
  assert ord(letra) is int</code>
  </section>
  <section>
    <h1>Desafio</h1>
    <p>El &#x27;char&#x27; es un valor numerico ordinal, si a un &#x27;A&#x27; le sumas &#x27;32&#x27; da un &#x27;a&#x27;,
    usando este simple hecho desarrolla un programa para convertir un &#x27;string&#x27; desde MAYUSCULAS hacia minusculas.</p>
    <code>var mayuscula = &#x27;A&#x27;                       # Letra &#x27;A&#x27; (mayuscula).
var minuscula = char(ord(mayuscula) + 32) # Letra &#x27;a&#x27; (minuscula).
assert minuscula == &#x27;a&#x27;                   # Minuscula es &#x27;a&#x27;

var resultado = &quot;&quot;
for letra in &quot;GATO&quot;:

  # Edita tu codigo aca.

  resultado.add(minuscula)
assert resultado == &quot;gato&quot;</code>
  </section>
  <section>
    <h1>Leer y Escribir Archivos</h1>
    <p>Para leer archivos se usa &#x27;readFile&#x27;,
    la funcion &#x27;readFile&#x27; toma un argumento de tipo &#x27;string&#x27; que es la ruta al archivo en el disco de la PC,
    y devuelve un resultado de tipo &#x27;string&#x27; que es el contenido del archivo.
    La ruta al archivo debe existir en el disco de la PC.
    El programa debe poder leer el archivo.</p>
    <p>Para escribir archivos se usa &#x27;writeFile&#x27;,
    la funcion &#x27;writeFile&#x27; toma dos argumentos de tipo &#x27;string&#x27;,
    uno es la ruta al archivo en el disco de la PC y el otro es el contenido del archivo,
    esta funcion no retorna ningun resultado.
    El programa debe poder escribir el archivo.</p>
    <code>writeFile(&quot;&#x2F;tmp&#x2F;ejemplo.txt&quot;, &quot;contenidos&quot;)   # La ruta al archivo debe existir en la PC.
var contenido = readFile(&quot;&#x2F;tmp&#x2F;ejemplo.txt&quot;)
echo contenido</code>
  </section>
  <section>
    <h1>Funciones</h1>
    <p>Una funcion o procedimiento es un bloque de codigo que se puede ejecutar por su nombre,
    puede tomar ninguno, uno o mas argumentos, los argumentos tambien tienen un nombre y tipo,
    usando la sintaxis &#x27;nombre: tipo&#x27; y separados por coma,
    pueden devolver un resultado, el resultado siempre tiene el nombre &#x27;result&#x27;,
    la variable &#x27;result&#x27; es automaticamente creada dentro del bloque de codigo de la funcion,
    puedes asignar los resultados a &#x27;result&#x27; en el cuerpo de la funcion,
    se construye con &#x27;proc&#x27; y el nombre de la funcion,
    tambien sus argumentos con sus tipos, y el tipo del &#x27;result&#x27; si es que retorna algo.</p>
    <p>Debes declarar una funcion antes de poder usarla.
    Usa nombres descriptivos para las funciones,
    piensa que el codigo debe ser facil de entender para otras personas.</p>
    <p>Es posible &quot;autodetectar&quot; el tipo de argumento o tipo de resultado de una funcion,
    usando el tipo &#x27;auto&#x27; como tipo de argumento o tipo de retorno,
    usando &#x27;auto&#x27; el programa intentara inferir el tipo desde el codigo,
    puede fallar en ejecutarse si no logra inferir el tipo,
    es mejor usar un tipo de dato concreto si se lo conoce.</p>
    <code># Esta funcion no toma ningun argumento, y no retorna un resultado.
proc ejemplo0() =
  echo &quot;Hola mundo&quot;

ejemplo0()


# Esta funcion no toma ningun argumento, y retorna un &#x27;result&#x27; de tipo &#x27;string&#x27;.
proc ejemplo1(): string =    # El tipo de &#x27;result&#x27; va aqui.
  result = &quot;resultado&quot;     # Se asigna a la variable &#x27;result&#x27;.

echo ejemplo1()


# Esta funcion toma un argumento, y retorna un &#x27;result&#x27; de tipo &#x27;string&#x27;.
proc ejemplo2(texto: string): string =
  result = &quot;Hola &quot;   # Asigna un &#x27;string&#x27; a &#x27;result&#x27;.
  result.add(texto)  # Usa &#x27;add&#x27; para agregar un &#x27;string&#x27; a otro &#x27;string&#x27;.

echo ejemplo2(&quot;Mundo&quot;)


# Esta funcion toma varios argumentos, y retorna un &#x27;result&#x27; de tipo &#x27;int&#x27;.
proc ejemplo3(num0: int, num1: int, num2: int): int =   # Los argumentos se separan con coma.
  result = num0 + num1 + num2

echo ejemplo3(1, 2, 3)


# Esta funcion toma argumentos y retorna un &#x27;result&#x27; pero todos usan tipo &#x27;auto&#x27;.
proc ejemplo4(num0: auto, num1: auto, num2: auto): auto =
  result = num0 + num1 + num2

echo ejemplo4(1, 2, 3)</code>
  </section>
  <section>
    <h1>Desafio</h1>
    <p>Lenguaje inclusivo: Realiza un programa para convertir palabras,
    cambiando el anteultimo caracter desde &#x27;o&#x27; hacia &#x27;e&#x27;,
    el programa toma como argumento una secuencia de &#x27;string&#x27; y devuelve un resultado tipo &#x27;string&#x27;,
    si y solo si el anteultimo caracter es &#x27;o&#x27;,
    es decir si el anteultimo caracter es &#x27;o&#x27;, entonces cambiarlo por &#x27;e&#x27;,
    parece como un &#x27;if&#x27; verdad?.</p>
    <code>proc inclusivador(palabras: seq[string]): string =
  for palabra in palabras:
    var variable = palabra
    # EDITA EL CODIGO ACA.

# Debe mostrar &quot;todes les programadores&quot;.
echo inclusivador(@[&quot;todos&quot;, &quot;los&quot;, &quot;programadores&quot;])</code>
  </section>
  <section>
    <h1>Libreria Estandard</h1>
    <p>Libreria Estandard (standard library), son archivos con funciones,
    las funciones se pueden usar importandolas en nuestro codigo usando &#x27;import&#x27;,
    y agregan funcionalidades utiles &quot;listas para usar&quot;,
    de una manera mas facil que implementando todo manualmente.
    A veces se abrevia &quot;Libreria Estandard&quot; como &quot;stdlib&quot;.
    La documentacion de la Libreria Estandard usualmente se encuentra disponible via web,
    y suele incluir ejemplos de como usar las funciones,
    con sus tipos de argumentos y tipos de retorno.
    La &quot;stdlib&quot; suele incluir funcionalidades para todos los niveles,
    asi que no te asustes si no entiendes aun alguna funcion de la Libreria Estandard.</p>
    <ul>
      <li><a href="https://nim-lang.github.io/Nim/lib.html" target="_blank">Documentacion de la Libreria Estandard.</a></li>
      <li><a href="https://nim-lang.github.io/Nim/manual.html" target="_blank">Manual para usuarios.</a></li>
    </ul>
    <code>import terminal  # https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;terminal.html
import strutils  # https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;strutils.html
import strformat # https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;strformat.html


# &#x27;strutils.parseInt&#x27; puede obtener un &#x27;int&#x27; dentro de un &#x27;string&#x27;.
var a = parseInt(&quot;42&quot;)
assert a is int
# &#x27;strutils.parseFloat&#x27; puede parsear un &#x27;float&#x27; dentro de un &#x27;string&#x27;.
var b = parseFloat(&quot;3.14&quot;)
assert b is float
# &#x27;strutils.parseBool&#x27; puede parsear un &#x27;bool&#x27; dentro de un &#x27;string&#x27;.
var c = parseBool(&quot;true&quot;)
assert c is bool


# &#x27;strformat.fmt&#x27; permite crear &#x27;string&#x27; formateadas con valores literales o variables.
echo fmt&quot;a es {a}, b es {b}, c es {c}&quot;
echo fmt&quot;suma {1 + 2}, resta {4 - 2}&quot;


# &#x27;terminal.styledEcho&#x27; es similar a &#x27;echo&#x27; pero con colores.
styledEcho fgRed, bgBlue, &quot; Hola Mundo &quot;
styledEcho fgYellow, bgBlack, &quot; en Colores &quot;</code>
  </section>
  <section>
    <h1>Tablas</h1>
    <p>Tablas son una collecion o mapeo de &#x27;clave: valor&#x27;,
    donde cada clave tiene un valor, el valor puede tener uno o mas items,
    el valor tambien puede estar vacio, como un &#x27;string&#x27; vacio o un &#x27;int&#x27; que es cero,
    puedes leer y escribir un valor con una clave en una variable.
    Tablas es parte de la Libreria Estandard y necesita ser importado usando &#x27;import tables&#x27;.
    Tablas tambien es llamado &quot;diccionario&quot; o &quot;mapeo&quot; o &quot;hashmap&quot;.</p>
    <ul>
      <li>Para convertir a Tabla se usa &#x27;toTable&#x27;.</li>
      <li>Para obetener la longitud de una Tabla se usa &#x27;len&#x27;.</li>
      <li>Para leer un valor por su clave se usa &#x27;[]&#x27;, es decir tabla[clave].</li>
      <li>Para escribir un valor por su clave se usa &#x27;[]=&#x27;, es decir tabla[clave] = valor.</li>
      <li>Para borrar una clave de una Tabla se puede usar &#x27;del&#x27;, es decir tabla.del(clave).</li>
      <li>Para saber si una clave existe en una Tabla se puede usar &#x27;in&#x27;, es decir valor in tabla.</li>
      <li>Para saber si una clave no existe en una Tabla se puede usar &#x27;notin&#x27;, es decir valor notin tabla.</li>
      <li>Para crear una Tabla sin ningun valor literal se usa &#x27;initTable&#x27; con los tipos de clave y valor.</li>
    </ul>
    <code>import tables

var tabla = {&quot;clave&quot;: &quot;valor&quot;}.toTable
assert tabla[&quot;clave&quot;] == &quot;valor&quot;
tabla[&quot;clave&quot;] = &quot;nuevo&quot;
assert tabla[&quot;clave&quot;] == &quot;nuevo&quot;
echo len(tabla)
tabla.add(&quot;otro&quot;, &quot;valor&quot;)
assert &quot;otro&quot; in tabla
tabla.del(&quot;otro&quot;)
assert &quot;otro&quot; notin tabla
var vacia = initTable[string, int]()  # Tabla vacia con clave tipo &#x27;string&#x27; y valor tipo &#x27;int&#x27;.
var otra = initTable[string, float]() # Tabla vacia con clave tipo &#x27;string&#x27; y valor tipo &#x27;float&#x27;.</code>
  </section>
</div>