<div>
  <section>
    <h1>For</h1>
    <p>El bucle &#x27;for&#x27; sirve para iterar un valor iterable,
    para aplicar algun tipo de logica a los items individualmente,
    es posible iterar por indices o por los items directamente,
    &#x27;for&#x27; itera de inicio a fin de algun argumento iterable.
    El bucle &#x27;for&#x27; puede ser interrumpido usando &#x27;break&#x27;.</p>
    <p>Aqui se presenta el operador &#x27;..&#x27;,
    que sirve para para crear rangos de valores ordinales, como valores numericos.</p>
    <p>Tambien existe el operador &#x27;..&lt;&#x27;, que es similar al &#x27;..&#x27; pero es no-inclusivo,
    quiere decir que el ultimo numero mas alto no esta incluido en el rango generado,
    es decir que &#x27;a..&lt;b&#x27; es igual a &#x27;a..(b - 1)&#x27; pero nos ahorra codigo,
    algunas implementaciones de codigo necesitaran el &#x27;..&#x27; y otras el &#x27;..&lt;&#x27;.</p>
    <code>var secuencia = @[1, 2, 3, 4, 5, 6]
for item in secuencia:
  if item mod 2 == 0:
    echo &quot;item es par&quot;
  else:
    echo &quot;item es impar&quot;

var palabra: string
for item in [&quot;v&quot;, &quot;e&quot;, &quot;r&quot;, &quot;d&quot;, &quot;e&quot;]:
  palabra.add(item)
assert palabra == &quot;verde&quot;

for i in 0..0:
  echo &quot;Esto se ejecuta 1 sola vez por que el rango tiene 1 item&quot;

for i in 5..9:
  echo i
  if i == 7: break</code>
  </section>
  <section>
    <h1>While</h1>
    <p>El bucle &#x27;while&#x27; sirve para repetir un bloque de codigo siempre y
    cuando un argumento de condicion booleana sea verdadera.
    El bucle &#x27;while&#x27; puede ser interrumpido usando &#x27;break&#x27;.</p>
    <p>Aqui se usa por primera vez los operadores &#x27;inc&#x27; y &#x27;dec&#x27;,
    &#x27;inc&#x27; es para incrementar valores ordinales, como valores numericos,
    permite poder escribir &#x27;inc i&#x27; en lugar de &#x27;i = i + 1&#x27;,
    &#x27;dec&#x27; es para decrementar valores, como valores numericos,
    permite poder escribir &#x27;dec i&#x27; en lugar de &#x27;i = i - 1&#x27; y nos ahorra codigo.</p>
    <code>var x = 0
while not(x == 9):
  echo x
  inc x  # x = x + 1

var y = 9
while not(y == 0):
  echo y
  dec y  # y = y - 1

var z = 0
while true:
  echo z
  inc z
  if z == 9: break</code>
  </section>
  <section>
    <h1>Char</h1>
    <p>Ahora que sabemos usar bucles podemos iterar el texto en los &#x27;string&#x27;,
    descubriremos que las letras individuales tambien tienen un tipo concreto,
    el caracter &#x27;char&#x27; representa 1 letra, de ahi viene el nombre &quot;cadena de caracteres&quot;,
    el char se construye con dos comillas simples y solo puede contener 1 caracter.
    El espacio en blanco, tabulador y la nueva linea (salto de linea) tambien son caracteres.</p>
    <p>La computadora representa las letras en el texto como numeros enteros,
    por lo tanto un &#x27;char&#x27; es compatible con un &#x27;int&#x27;, es un valor ordinal numerico,
    &#x27;char&#x27; puede usar &#x27;inc&#x27;, &#x27;dec&#x27;, &#x27;..&#x27;, &#x27;..&lt;&#x27;, &#x27;+&#x27;, &#x27;-&#x27; que vimos anteriormente.</p>
    <p>Los &#x27;char&#x27; son ordinales, por ejemplo el valor entero del &#x27;char&#x27; de &#x27;a&#x27; es &#x27;97&#x27;,
    si a &#x27;a&#x27; le sumas 1 obtienes &#x27;b&#x27;, si al &#x27;a&#x27; le sumas 2 obtienes &#x27;c&#x27;, etc.</p>
    <ul>
      <li>&#x27;char&#x27; se puede convertir en &#x27;int&#x27; usando &#x27;ord&#x27;.</li>
      <li>&#x27;int&#x27; se puede convertir en &#x27;char&#x27; usando &#x27;char&#x27;.</li>
      <li>Es posible agregar uno o mas &#x27;char&#x27; a un &#x27;string&#x27; usando &#x27;add&#x27;.</li>
      <li>Puedes obtener un &#x27;char&#x27; de un &#x27;string&#x27; por su indice usando &#x27;[]&#x27;,
      es decir &#x27;texto[3]&#x27; para el &#x27;char&#x27; en la posicion &#x27;3&#x27; del &#x27;string&#x27; texto.</li>
    </ul>
    <code>var caracter = &#x27;a&#x27;
assert caracter is char

var texto = &quot;ave&quot;
assert texto[1] == &#x27;v&#x27;
texto.add(&#x27;s&#x27;)
assert texto == &quot;aves&quot;

for letra in &quot;ejemplo&quot;:  # Es posible iterar los &#x27;char&#x27; de un &#x27;string&#x27; directamente.
  echo letra, &#x27; &#x27;, ord(letra)   # &#x27; &#x27; es un char de Espacio.
  assert letra is char
  assert ord(letra) is int

for letra in &#x27;a&#x27;..&#x27;z&#x27;:  # Como es un valor ordinal se puede crear rangos de letras.
  echo letra, &#x27;\t&#x27;, ord(letra)  # &#x27;\t&#x27; es un caracter de Tabulador (Tab).
  assert letra is char
  assert ord(letra) is int</code>
  </section>
  <section>
    <h1>UFCS: llamadas a funcion</h1>
    <p>Puedes llamar una funcion de la manera que sea mas comoda y
    mas adecuada al contexto que estes trabajando en el codigo.
    Antiguamente algunas funciones se llamaban de la manera &#x27;funcion(argumento)&#x27;,
    otras funciones se llamaban de la manera &#x27;funcion argumento&#x27;,
    e inclusive se llamaban de la manera &#x27;argumento.funcion&#x27;,
    a veces la forma cambiaba y el codigo se rompia,
    o se usaba la manera incorrecta y el codigo fallaba,
    para solucionar estos problemas (Bugs),
    se penso una nueva manera de hacer las llamadas a funcion,
    haciendo que el compilador trabaje por nosotros.</p>
    <p>Todas las formas se interpretan como si fueran exactamente iguales,
    es decir &#x27;funcion(argumento)&#x27;, &#x27;funcion argumento&#x27;, &#x27;argumento.funcion&#x27;, etc
    son exactamente lo mismo y compilan a exactamente el mismo codigo.</p>
    <p>Tambien permite encadenar funciones de manera automatica sin necesidad de modificar dichas funciones,
    es decir &#x27;argumento.funcion.funcion.funcion.funcion()&#x27;, etc
    y compilan exactamente al mismo codigo.
    Es agnostico del formato de llamada a funcion usado.</p>
    <code>import strutils

echo &quot;Hola Mundo&quot;
echo(&quot;Hola Mundo&quot;)
&quot;Hola Mundo&quot;.echo()
&quot;Hola Mundo&quot;.echo

# Estas funciones encadenadas
echo &quot;  42 666  &quot;.unindent.strip.normalize.split
# Es exactamente lo mismo que escribir
echo(split(normalize(strip(unindent(&quot;  42 666  &quot;)))))</code>
  </section>
  <section>
    <h1>Desafio</h1>
    <p>El &#x27;char&#x27; es un valor numerico ordinal, si a un &#x27;A&#x27; le sumas &#x27;32&#x27; da un &#x27;a&#x27;,
    usando este simple hecho desarrolla un programa para convertir un &#x27;string&#x27; desde MAYUSCULAS hacia minusculas.</p>
    <code>var mayuscula = &#x27;A&#x27;                       # Letra &#x27;A&#x27; (mayuscula).
var minuscula = char(ord(mayuscula) + 32) # Letra &#x27;a&#x27; (minuscula).
assert minuscula == &#x27;a&#x27;                   # Minuscula es &#x27;a&#x27;

var resultado = &quot;&quot;
for letra in &quot;GATO&quot;:

  # Edita tu codigo aca.

  resultado.add(minuscula)
assert resultado == &quot;gato&quot;</code>
  </section>
  <section>
    <h1>Leer y Escribir Archivos</h1>
    <p>Para leer archivos se usa &#x27;readFile&#x27;,
    la funcion &#x27;readFile&#x27; toma un argumento de tipo &#x27;string&#x27; que es la ruta al archivo en el disco de la PC,
    y devuelve un resultado de tipo &#x27;string&#x27; que es el contenido del archivo.
    La ruta al archivo debe existir en el disco de la PC.
    El programa debe poder leer el archivo.</p>
    <p>Para escribir archivos se usa &#x27;writeFile&#x27;,
    la funcion &#x27;writeFile&#x27; toma dos argumentos de tipo &#x27;string&#x27;,
    uno es la ruta al archivo en el disco de la PC y el otro es el contenido del archivo,
    esta funcion no retorna ningun resultado.
    El programa debe poder escribir el archivo.</p>
    <code>writeFile(&quot;&#x2F;tmp&#x2F;ejemplo.txt&quot;, &quot;contenidos&quot;)   # La ruta al archivo debe existir en la PC.
var contenido = readFile(&quot;&#x2F;tmp&#x2F;ejemplo.txt&quot;)
echo contenido</code>
  </section>
  <section>
    <h1>Funciones</h1>
    <p>Una funcion o procedimiento es un bloque de codigo que se puede ejecutar por su nombre,
    puede tomar ninguno, uno o mas argumentos, los argumentos tambien tienen un nombre y tipo,
    usando la sintaxis &#x27;nombre: tipo&#x27; y separados por coma,
    pueden devolver un resultado, el resultado siempre tiene el nombre &#x27;result&#x27;,
    la variable &#x27;result&#x27; es automaticamente creada dentro del bloque de codigo de la funcion,
    puedes asignar los resultados a &#x27;result&#x27; en el cuerpo de la funcion,
    se construye con &#x27;proc&#x27; y el nombre de la funcion,
    tambien sus argumentos con sus tipos, y el tipo del &#x27;result&#x27; si es que retorna algo.</p>
    <p>Debes declarar una funcion antes de poder usarla.
    Usa nombres descriptivos para las funciones,
    piensa que el codigo debe ser facil de entender para otras personas.</p>
    <p>Es posible &quot;autodetectar&quot; el tipo de argumento o tipo de resultado de una funcion,
    usando el tipo &#x27;auto&#x27; como tipo de argumento o tipo de retorno,
    usando &#x27;auto&#x27; el programa intentara inferir el tipo desde el codigo,
    puede fallar en ejecutarse si no logra inferir el tipo,
    tambien hay que pensar que &quot;el codigo es documentacion&quot;,
    y al ver que un argumento debe ser &#x27;int&#x27; ya sabes que tipo de dato usar,
    pero si esta todo en &#x27;auto&#x27; es mas dificil entender que tipo de dato usar,
    es mejor usar un tipo de dato concreto si se lo conoce.</p>
    <code># Esta funcion no toma ningun argumento, y no retorna un resultado.
proc ejemplo0() =
  echo &quot;Hola mundo&quot;

ejemplo0()


# Esta funcion no toma ningun argumento, y retorna un &#x27;result&#x27; de tipo &#x27;string&#x27;.
proc ejemplo1(): string =    # El tipo de &#x27;result&#x27; va aqui.
  result = &quot;resultado&quot;     # Se asigna a la variable &#x27;result&#x27;.

echo ejemplo1()


# Esta funcion toma un argumento, y retorna un &#x27;result&#x27; de tipo &#x27;string&#x27;.
proc ejemplo2(texto: string): string =
  result = &quot;Hola &quot;   # Asigna un &#x27;string&#x27; a &#x27;result&#x27;.
  result.add(texto)  # Usa &#x27;add&#x27; para agregar un &#x27;string&#x27; a otro &#x27;string&#x27;.

echo ejemplo2(&quot;Mundo&quot;)


# Esta funcion toma varios argumentos, y retorna un &#x27;result&#x27; de tipo &#x27;int&#x27;.
proc ejemplo3(num0: int, num1: int, num2: int): int =   # Los argumentos se separan con coma.
  result = num0 + num1 + num2

echo ejemplo3(1, 2, 3)


# Esta funcion toma argumentos y retorna un &#x27;result&#x27; pero todos usan tipo &#x27;auto&#x27;.
proc ejemplo4(num0: auto, num1: auto, num2: auto): auto =
  result = num0 + num1 + num2

echo ejemplo4(1, 2, 3)</code>
  </section>
  <section>
    <h1>Tuplas</h1>
    <p>Las tuplas son colleciones de items que pueden contener items de distintos tipos,
    existen 2 tipos de tuplas, tuplas anonimas donde los items no tienen nombre,
    los items de la tupla anonima solo se pueden leer por su indice,
    y tuplas nombradas donde cada item tienen un nombre,
    los items de la tupla nombrada se pueden leer por su indice y por su nombre.</p>
    <p>Las tuplas son de capacidad fija, es decir no pueden crecer,
    no se puede agregar mas items a una tupla, pero se puede modificar los valores existentes.
    Las tuplas son muy utiles en las funciones para retornar mas de un valor en el &#x27;result&#x27;.</p>
    <code>var tuplaAnon = (9, true, &quot;UwU&quot;, 2.0, false, -5)
assert tuplaAnon is tuple
assert tuplaAnon[2] == &quot;UwU&quot;
var tuplaNombrada = (clave0: 9, clave1: true, clave2: &quot;OwO&quot;)
assert tuplaNombrada is tuple
assert tuplaNombrada[2] == &quot;OwO&quot;
assert tuplaNombrada.clave2 == &quot;OwO&quot;

proc retornaMuchasCosas(): auto =
  result = (clave0: 9, clave1: true, clave2: &quot;texto&quot;, clave3: 3.14)

echo retornaMuchasCosas()</code>
  </section>
  <section>
    <h1>Libreria Estandard</h1>
    <p>Libreria Estandard (standard library), son archivos con funciones,
    las funciones se pueden usar importandolas en nuestro codigo usando &#x27;import&#x27;,
    y agregan funcionalidades utiles &quot;listas para usar&quot;,
    de una manera mas facil que implementando todo manualmente.
    A veces se abrevia &quot;Libreria Estandard&quot; como &quot;stdlib&quot;.
    La documentacion de la Libreria Estandard usualmente se encuentra disponible via web,
    y suele incluir ejemplos de como usar las funciones,
    con sus tipos de argumentos y tipos de retorno.
    La &quot;stdlib&quot; suele incluir funcionalidades para todos los niveles,
    asi que no te asustes si no entiendes aun alguna funcion de la Libreria Estandard.
    No es necesario que memorizes la Libreria Estandard,
    siempre se trabaja con su documentacion web como guia.
    Mas adelante aprenderemos cosas mas avanzadas de la Libreria Estandard.</p>
    <ul>
      <li><a href="https://nim-lang.github.io/Nim/lib.html">Documentacion de la Libreria Estandard.</a></li>
      <li><a href="https://nim-lang.github.io/Nim/manual.html">Manual para usuarios.</a></li>
    </ul>
    <code>import terminal  # https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;terminal.html
import strutils  # https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;strutils.html
import strformat # https:&#x2F;&#x2F;nim-lang.github.io&#x2F;Nim&#x2F;strformat.html


# &#x27;strutils.parseInt&#x27; puede obtener un &#x27;int&#x27; dentro de un &#x27;string&#x27;.
var a = parseInt(&quot;42&quot;)
assert a is int
# &#x27;strutils.parseFloat&#x27; puede parsear un &#x27;float&#x27; dentro de un &#x27;string&#x27;.
var b = parseFloat(&quot;3.14&quot;)
assert b is float
# &#x27;strutils.parseBool&#x27; puede parsear un &#x27;bool&#x27; dentro de un &#x27;string&#x27;.
var c = parseBool(&quot;true&quot;)
assert c is bool


# &#x27;strformat.fmt&#x27; permite crear &#x27;string&#x27; formateadas con valores literales o variables.
echo fmt&quot;a es {a}, b es {b}, c es {c}&quot;
echo fmt&quot;suma {1 + 2}, resta {4 - 2}&quot;


# &#x27;terminal.styledEcho&#x27; es similar a &#x27;echo&#x27; pero con colores.
styledEcho fgRed, bgBlue, &quot; Hola Mundo &quot;
styledEcho fgYellow, bgGreen, &quot; en Colores &quot;</code>
  </section>
  <section>
    <h1>Tablas</h1>
    <p>Tablas son una collecion o mapeo de &#x27;clave: valor&#x27;,
    solo puede contener items de un mismo tipo para clave o valor,
    es decir todas las claves deben ser del mismo tipo,
    y todos los valores deben ser del mismo tipo,
    donde cada clave tiene un valor, el valor puede tener uno o mas items,
    el valor tambien puede estar vacio, como un &#x27;string&#x27; vacio o un &#x27;int&#x27; que es cero,
    puedes leer y escribir un valor con una clave en una variable.
    Tablas es parte de la Libreria Estandard y necesita ser importado usando &#x27;import tables&#x27;.
    Tablas tambien es llamado &quot;diccionario&quot; o &quot;mapeo&quot; o &quot;hashmap&quot;.</p>
    <ul>
      <li>Para convertir a Tabla se usa &#x27;toTable&#x27;.</li>
      <li>Para obtener la longitud de una Tabla se usa &#x27;len&#x27;.</li>
      <li>Para leer un valor por su clave se usa &#x27;[]&#x27;, es decir tabla[clave].</li>
      <li>Para escribir un valor por su clave se usa &#x27;[]=&#x27;, es decir tabla[clave] = valor.</li>
      <li>Para borrar una clave de una Tabla se puede usar &#x27;del&#x27;, es decir tabla.del(clave).</li>
      <li>Para saber si una clave existe en una Tabla se puede usar &#x27;in&#x27;, es decir valor in tabla.</li>
      <li>Para saber si una clave no existe en una Tabla se puede usar &#x27;notin&#x27;, es decir valor notin tabla.</li>
      <li>Para crear una Tabla sin ningun valor literal se usa &#x27;initTable&#x27; con los tipos de clave y valor.</li>
    </ul>
    <code>import tables

var tabla = {&quot;clave&quot;: &quot;valor&quot;}.toTable
assert tabla[&quot;clave&quot;] == &quot;valor&quot;
tabla[&quot;clave&quot;] = &quot;nuevo&quot;
assert tabla[&quot;clave&quot;] == &quot;nuevo&quot;
echo len(tabla)
tabla.add(&quot;otro&quot;, &quot;valor&quot;)
assert &quot;otro&quot; in tabla
echo tabla

for key, value in tabla:
  echo key, &#x27; &#x27;, value

tabla.del(&quot;otro&quot;)
assert &quot;otro&quot; notin tabla

var vacia = initTable[string, int]()  # Tabla vacia con clave tipo &#x27;string&#x27; y valor tipo &#x27;int&#x27;.
assert len(vacia) == 0
var otra = initTable[string, float]() # Tabla vacia con clave tipo &#x27;string&#x27; y valor tipo &#x27;float&#x27;.
assert len(otra) == 0

echo {
  &quot;nombre&quot;: &quot;pepe&quot;,
  &quot;id&quot;:     &quot;abc123&quot;,
}.toTable</code>
  </section>
  <section>
    <h1>JSON</h1>
    <p>JSON es un mapeo de &#x27;clave: valor&#x27;,
    puede contener items de cualquier tipo para los valores, incluido tipos mixtos mezclados,
    todas las claves deben ser siempre de tipo &#x27;string&#x27;,
    y todos los valores no deben ser del mismo tipo, los valores pueden ser de cualquier tipo,
    donde cada clave tiene un valor, el valor puede tener uno o mas items,
    el valor tambien puede estar vacio, como un &#x27;string&#x27; vacio o un &#x27;int&#x27; que es cero,
    puedes leer y escribir un valor con una clave en una variable.
    JSON es de capacidad dinamica, es decir puede crecer,
    se pueden agregar mas items a un JSON y se puede modificar los valores existentes tambien.
    JSON es siempre de tipo &#x27;JsonNode&#x27;.
    JSON es parte de la Libreria Estandard y necesita ser importado usando &#x27;import json&#x27;.</p>
    <ul>
      <li>Para convertir a JSON se usa &#x27;%*&#x27;.</li>
      <li>Para convertir valores individuales a JSON se usa &#x27;%&#x27;, es decir %valor.</li>
      <li>Para obtener la longitud de un JSON se usa &#x27;len&#x27;.</li>
      <li>Para leer un valor por su clave se usa &#x27;[]&#x27;, es decir jsn[clave].</li>
      <li>Para escribir un valor por su clave se usa &#x27;[]=&#x27;, es decir jsn[clave] = valor.</li>
      <li>Para borrar una clave de una Tabla se puede usar &#x27;del&#x27;, es decir tabla.del(clave).</li>
      <li>Para saber si una clave existe en una Tabla se puede usar &#x27;in&#x27;, es decir valor in tabla.</li>
      <li>Para saber si una clave no existe en una Tabla se puede usar &#x27;notin&#x27;, es decir valor notin tabla.</li>
      <li>Para mostrar JSON con un formato amigable para humanos &#x27;pretty&#x27;.</li>
      <li>Para convertir &#x27;string&#x27; a JSON se usa &#x27;parseJson&#x27;.</li>
    </ul>
    <code>import json

var jsn = %*{&quot;clave&quot;: &quot;valor&quot;}
assert jsn[&quot;clave&quot;] == %&quot;valor&quot;
jsn[&quot;clave&quot;] = %&quot;nuevo&quot;
assert jsn[&quot;clave&quot;] == %&quot;nuevo&quot;
echo len(jsn)
assert &quot;clave&quot; in jsn
assert &quot;inexistente&quot; notin jsn
jsn.add(&quot;otro&quot;, %&quot;valor&quot;)
echo jsn
echo pretty(jsn)
jsn.delete(&quot;otro&quot;)

var vacia = %*{}  # JSON vacio.
assert len(vacia) == 0

var ejemplo = pretty(%*{
  &quot;nombre&quot;: &quot;pepe&quot;, # El valor es &#x27;string&#x27;.
  &quot;id&quot;:     42,     # El valor es &#x27;int&#x27;.
  &quot;rank&quot;:   3.14,   # El valor es &#x27;float&#x27;.
  &quot;online&quot;: true,   # El valor es &#x27;bool&#x27;.
})
echo ejemplo
assert ejemplo is string
# Obtener JSON desde un &#x27;string&#x27;.
assert parseJson(ejemplo) is JsonNode</code>
  </section>
</div>